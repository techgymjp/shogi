<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>挟み将棋</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Kaku Gothic Pro', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 600px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .rules {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .rules h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .rules ul {
            margin-left: 20px;
        }

        .rules li {
            margin-bottom: 5px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .player-info {
            font-size: 1.1em;
            font-weight: bold;
        }

        .player-human {
            color: #2563eb;
        }

        .player-computer {
            color: #dc2626;
        }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            gap: 1px;
            background: #333;
            padding: 1px;
            border: 3px solid #8b4513;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .cell {
            width: 50px;
            height: 50px;
            background: #f5deb3;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .cell:hover {
            background: #ffe4b3;
        }

        .cell.selected {
            background: #ffc107;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        .cell.valid-move {
            background: #90ee90;
        }

        .cell.last-move {
            background: #ffeb99;
        }

        .piece {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            font-weight: bold;
            user-select: none;
            transition: transform 0.2s;
        }

        .piece.human {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .piece.computer {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .piece:hover {
            transform: scale(1.1);
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
        }

        .status.thinking {
            background: #fff3cd;
        }

        .status.game-over {
            background: #f8d7da;
            color: #721c24;
            font-size: 1.3em;
        }

        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .new-game-btn {
            background: #2563eb;
            color: white;
        }

        .new-game-btn:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }

        .toggle-rules-btn {
            background: #667eea;
            color: white;
        }

        .toggle-rules-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .rules.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>挟み将棋</h1>
        
        <div class="rules" id="rules">
            <h3>ルール</h3>
            <ul>
                <li>各プレイヤーは9個の駒を持ちます</li>
                <li>駒は縦横に何マスでも移動できます（斜めは不可）</li>
                <li>相手の駒を自分の2つの駒で挟むと取れます</li>
                <li>相手の駒を1個だけ残すまで取ると勝ちです</li>
            </ul>
        </div>

        <div class="game-info">
            <div class="player-info player-computer">
                <span>コンピュータ: <span id="computer-pieces">9</span>個</span>
            </div>
            <div class="player-info player-human">
                <span>あなた: <span id="human-pieces">9</span>個</span>
            </div>
        </div>

        <div class="board-container">
            <div class="board" id="board"></div>
        </div>

        <div class="status" id="status">あなたの番です</div>

        <div class="buttons">
            <button class="new-game-btn" onclick="game.newGame()">新しいゲーム</button>
            <button class="toggle-rules-btn" onclick="toggleRules()">ルールを隠す/表示</button>
        </div>
    </div>

    <script>
        class HasamiShogiGame {
            constructor() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.currentPlayer = 'human';
                this.selectedCell = null;
                this.validMoves = [];
                this.gameOver = false;
                this.lastMove = null;
                this.initBoard();
                this.render();
            }

            initBoard() {
                // コンピュータの駒を最上段に配置
                for (let col = 0; col < 9; col++) {
                    this.board[0][col] = { player: 'computer' };
                }

                // 人間の駒を最下段に配置
                for (let col = 0; col < 9; col++) {
                    this.board[8][col] = { player: 'human' };
                }
            }

            render() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        // 最後の移動を強調表示
                        if (this.lastMove && 
                            ((this.lastMove.fromRow === row && this.lastMove.fromCol === col) ||
                             (this.lastMove.toRow === row && this.lastMove.toCol === col))) {
                            cell.classList.add('last-move');
                        }

                        // 選択されたセルを強調表示
                        if (this.selectedCell && 
                            this.selectedCell.row === row && 
                            this.selectedCell.col === col) {
                            cell.classList.add('selected');
                        }

                        // 有効な移動先を表示
                        if (this.validMoves.some(m => m.row === row && m.col === col)) {
                            cell.classList.add('valid-move');
                        }

                        // 駒を表示
                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.player}`;
                            pieceElement.textContent = '●';
                            cell.appendChild(pieceElement);
                        }

                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        boardElement.appendChild(cell);
                    }
                }

                // 駒の数を更新
                this.updatePieceCount();
            }

            updatePieceCount() {
                let humanCount = 0;
                let computerCount = 0;

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            if (piece.player === 'human') humanCount++;
                            else computerCount++;
                        }
                    }
                }

                document.getElementById('human-pieces').textContent = humanCount;
                document.getElementById('computer-pieces').textContent = computerCount;
            }

            handleCellClick(row, col) {
                if (this.gameOver || this.currentPlayer !== 'human') return;

                const piece = this.board[row][col];

                // 駒を選択
                if (piece && piece.player === 'human') {
                    this.selectedCell = { row, col };
                    this.validMoves = this.getValidMoves(row, col);
                    this.render();
                }
                // 移動先を選択
                else if (this.selectedCell && this.validMoves.some(m => m.row === row && m.col === col)) {
                    this.movePiece(this.selectedCell.row, this.selectedCell.col, row, col);
                }
                // 選択解除
                else {
                    this.selectedCell = null;
                    this.validMoves = [];
                    this.render();
                }
            }

            getValidMoves(row, col) {
                const moves = [];
                const directions = [
                    [-1, 0], // 上
                    [1, 0],  // 下
                    [0, -1], // 左
                    [0, 1]   // 右
                ];

                for (const [dr, dc] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;

                    // その方向に進めるだけ進む
                    while (newRow >= 0 && newRow < 9 && newCol >= 0 && newCol < 9) {
                        if (this.board[newRow][newCol] === null) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            break; // 駒がある場合は止まる
                        }
                        newRow += dr;
                        newCol += dc;
                    }
                }

                return moves;
            }

            movePiece(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;

                this.lastMove = { fromRow, fromCol, toRow, toCol };

                // 挟んだ駒を取る
                this.checkCaptures(toRow, toCol, piece.player);

                this.selectedCell = null;
                this.validMoves = [];
                this.render();

                // 勝利判定
                if (this.checkWin()) return;

                this.switchPlayer();
            }

            checkCaptures(row, col, player) {
                const opponent = player === 'human' ? 'computer' : 'human';
                const directions = [
                    [0, -1, 0, 1],   // 横方向（左と右）
                    [-1, 0, 1, 0]    // 縦方向（上と下）
                ];

                for (const [dr1, dc1, dr2, dc2] of directions) {
                    const capturedPieces = [];
                    
                    // 一方向に相手の駒を探す
                    let checkRow = row + dr1;
                    let checkCol = col + dc1;
                    
                    while (checkRow >= 0 && checkRow < 9 && checkCol >= 0 && checkCol < 9) {
                        const checkPiece = this.board[checkRow][checkCol];
                        
                        if (checkPiece === null) {
                            break; // 空きマス
                        } else if (checkPiece.player === opponent) {
                            capturedPieces.push({ row: checkRow, col: checkCol });
                        } else if (checkPiece.player === player) {
                            // 自分の駒で挟まれている場合、相手の駒を取る
                            for (const captured of capturedPieces) {
                                this.board[captured.row][captured.col] = null;
                            }
                            break;
                        }
                        
                        checkRow += dr1;
                        checkCol += dc1;
                    }
                }
            }

            checkWin() {
                let humanCount = 0;
                let computerCount = 0;

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            if (piece.player === 'human') humanCount++;
                            else computerCount++;
                        }
                    }
                }

                if (humanCount === 1) {
                    this.gameOver = true;
                    this.updateStatus('コンピュータの勝ちです！', true);
                    return true;
                } else if (computerCount === 1) {
                    this.gameOver = true;
                    this.updateStatus('あなたの勝ちです！おめでとうございます！', true);
                    return true;
                }

                return false;
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'human' ? 'computer' : 'human';
                
                if (this.currentPlayer === 'computer') {
                    this.updateStatus('コンピュータが考えています...', false, true);
                    setTimeout(() => this.computerMove(), 800);
                } else {
                    this.updateStatus('あなたの番です');
                }
            }

            computerMove() {
                const allMoves = this.getAllPossibleMoves('computer');
                
                if (allMoves.length === 0) {
                    this.gameOver = true;
                    this.updateStatus('あなたの勝ちです！', true);
                    return;
                }

                // 優先順位：
                // 1. 相手の駒を取れる手
                // 2. ランダムな手

                let bestMove = null;
                let maxCaptures = 0;

                for (const move of allMoves) {
                    // 仮想的に移動してみる
                    const piece = this.board[move.fromRow][move.fromCol];
                    const originalPiece = this.board[move.toRow][move.toCol];
                    
                    this.board[move.toRow][move.toCol] = piece;
                    this.board[move.fromRow][move.fromCol] = null;

                    // 何個取れるかカウント
                    const captures = this.countCaptures(move.toRow, move.toCol, 'computer');

                    // 元に戻す
                    this.board[move.fromRow][move.fromCol] = piece;
                    this.board[move.toRow][move.toCol] = originalPiece;

                    if (captures > maxCaptures) {
                        maxCaptures = captures;
                        bestMove = move;
                    }
                }

                // 取れる手がなければランダムに選ぶ
                if (!bestMove) {
                    bestMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                }

                this.movePiece(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
            }

            countCaptures(row, col, player) {
                const opponent = player === 'human' ? 'computer' : 'human';
                const directions = [
                    [0, -1, 0, 1],   // 横方向
                    [-1, 0, 1, 0]    // 縦方向
                ];

                let totalCaptures = 0;

                for (const [dr1, dc1, dr2, dc2] of directions) {
                    const capturedPieces = [];
                    
                    let checkRow = row + dr1;
                    let checkCol = col + dc1;
                    
                    while (checkRow >= 0 && checkRow < 9 && checkCol >= 0 && checkCol < 9) {
                        const checkPiece = this.board[checkRow][checkCol];
                        
                        if (checkPiece === null) {
                            break;
                        } else if (checkPiece.player === opponent) {
                            capturedPieces.push({ row: checkRow, col: checkCol });
                        } else if (checkPiece.player === player) {
                            totalCaptures += capturedPieces.length;
                            break;
                        }
                        
                        checkRow += dr1;
                        checkCol += dc1;
                    }
                }

                return totalCaptures;
            }

            getAllPossibleMoves(player) {
                const moves = [];

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.player === player) {
                            const validMoves = this.getValidMoves(row, col);
                            for (const move of validMoves) {
                                moves.push({
                                    fromRow: row,
                                    fromCol: col,
                                    toRow: move.row,
                                    toCol: move.col
                                });
                            }
                        }
                    }
                }

                return moves;
            }

            updateStatus(message, gameOver = false, thinking = false) {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = 'status';
                if (gameOver) {
                    status.classList.add('game-over');
                } else if (thinking) {
                    status.classList.add('thinking');
                }
            }

            newGame() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.currentPlayer = 'human';
                this.selectedCell = null;
                this.validMoves = [];
                this.gameOver = false;
                this.lastMove = null;
                this.initBoard();
                this.render();
                this.updateStatus('あなたの番です');
            }
        }

        function toggleRules() {
            const rules = document.getElementById('rules');
            rules.classList.toggle('hidden');
        }

        // ゲーム開始
        const game = new HasamiShogiGame();
    </script>
</body>
</html>
